#!/usr/bin/env ruby
#MIT License
#Copyright (c) 2018 phR0ze
#
#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.

#-----------------------------------------------------------------------------------------------
# Simple GTK+ UI for openvpn and tooling for simple VPN access
# https://developer.gnome.org/gtk3/stable
# https://lazka.github.io/pgi-docs/Gtk-3.0/classes.html
# https://lazka.github.io/pgi-docs/Gdk-3.0/constants.html
# https://github.com/ruby-gnome2/ruby-gnome2/tree/master/gtk3
#-----------------------------------------------------------------------------------------------
$root_path = File.dirname(File.expand_path(__FILE__))
$root_path = '/usr/share/vpnctl' if $root_path == '/usr/bin'
$LOAD_PATH.unshift($root_path)
load File.join(File.dirname(File.expand_path(__FILE__)), "vpnctl-cli")

# Packages available in cyberlinux or arch linux
begin
  require 'gtk3'
  require 'colorize'
  require 'lib/model'
  require 'lib/config'
  require 'lib/gtkassist'
rescue Exception => e
  mod = e.message.split(' ').last.sub('/', '-')
  !puts("Error: install missing package with 'sudo package -S ruby-#{mod}'") and exit
end

class VpnCtl
  def initialize
#    #!puts("Error: must be executed as root user".colorize(:red)) and exit unless Process.uid.zero?
    @datapath = File.dirname(File.expand_path(__FILE__))
    @datapath = '/usr/share/vpnctl' if File.basename(@datapath) != 'vpnctl'
    @images_path = File.join(@datapath, 'images')
    @icon_path = File.join(@images_path, '32x32')

    @icon = File.join(@icon_path, 'vpnctl.png')
#    @enabled_icon = File.join(@icon_path, 'vpnctl-enabled.png')
#    @targeted_icon = File.join(@icon_path, 'vpnctl-targeted.png')
#    @disabled_icon  = File.join(@icon_path, 'vpnctl-disabled.png')

    # Configure config and logging
    Config.init('vpnctl.yml')
    Log.init(path:"#{$root_path}/vpnctl.log", queue:true, stdout:true)

    # Track VPN state
    @vpn = nil    # active vpn
    @vpns = Config.vpns
    @ovpns = Dir[File.join(Config.ovpn_path, '*')]

#    # VPN thread communication
#    @halt = false
#    @vpn_comm_in = nil
#
    self.construct_ui
    self.connect_signals
  end

  # Inflate UI elements from glade xml files and create any dynamic UI needed
  # including populating ui widgets with data.
  def construct_ui
    @builder = Gtk::Builder.new
    @builder.add_from_file(File.join(@datapath, 'ui/vpnctl.ui'))
    GtkAssist.load_styles(File.join(@datapath, 'ui/styles.css'))

    # Setup mouse pointers
    @cursor_waiting = Gdk::Cursor.new("wait")
    @cursor_grabbing = Gdk::Cursor.new("grabbing")

    # Get handles for important ui objects
    @main_win = @builder.get_object("main-window")
    @vpnlist_box = @builder.get_object("vpn-list-box")
    @vpn_name = @builder.get_object("vpn-name-entry")
    @vpn_ovpn = @builder.get_object("vpn-ovpn-combo")
    @vpn_ovpn_entry = @builder.get_object("vpn-ovpn-entry")
    @vpn_logintype = @builder.get_object("vpn-logintype-combo")
    @vpn_user = @builder.get_object("vpn-username-entry")
    @vpn_pass = @builder.get_object("vpn-password-entry")
    @vpn_routes = @builder.get_object("vpn-routes-entry")
    @vpn_apps_sw = @builder.get_object("apps-switch")
    @vpn_apps = @builder.get_object("apps-text")
    @vpn_default = @builder.get_object("default-switch")
    @connect_btn = @builder.get_object("connect-button")
    @save_btn = @builder.get_object("save-button")

    # Configure windows/dialogs
    @main_win.icon = GdkPixbuf::Pixbuf.new(file:@icon)

#    @tray = create_system_tray_icon
#    @popup_menu = create_popup_menu
#    @logwin, @logview, @logiter = create_log_window
#    @settings = create_settings_window
    self.enable_repositioning(@main_win)
    self.populate_widgets
    GtkAssist.apply_styles(@main_win)
  end

  # Select the default or first vpn if doesn't exist
  def select_default_or_first_vpn
    if vpn = @vpns.find{|x| x.default}
      self.select_vpn(vpn.name)
    else
      self.select_vpn(@vpns.first.name) if @vpns.any?
    end
  end

  def populate_widgets
    # Populate ovpn configs
    @ovpns.each{|x| @vpn_ovpn.append_text(File.basename(x))}

    # Populate the login type combo box
    @vpn_logintype.append_text(Model::PassTypeDisplay[Model::PassTypes.ask])
    @vpn_logintype.append_text(Model::PassTypeDisplay[Model::PassTypes.save])

    # Read in vpns from config file and populate list
    # then select the default or first one
    @vpns.each{|vpn|
      vpn.btn = Gtk::Button.new(label: vpn.name)
      @vpnlist_box.pack_start(vpn.btn)
      vpn.btn.show
    }
    self.select_default_or_first_vpn
  end

  def activate_pass_entry
    ctx = @vpn_pass.style_context
    ctx.remove_class('entry-deactivate')
    @vpn_pass.text = @vpn.login.pass || ""
    @vpn_pass.placeholder_text = "VPN password"
    @vpn_pass.editable = true
    @vpn_pass.secondary_icon_activatable = true
  end

  def deactivate_pass_entry
    ctx = @vpn_pass.style_context
    ctx.add_class('entry-deactivate')
    @vpn_pass.text = ""
    @vpn_pass.placeholder_text = ""
    @vpn_pass.editable = false
    @vpn_pass.secondary_icon_activatable = false
  end

  # Select the given vpn from the list and populate ui
  # @param name [String] name of the vpn to select
  def select_vpn(name)
    @vpn = @vpns.find{|x| x.name == name}
    @vpn_name.text = @vpn.name
    @vpn_ovpn.active = @ovpns.index{|x| x == @vpn.ovpn} || -1
    @vpn_ovpn_entry.text = '' if @vpn_ovpn.active == -1
    @vpn_logintype.active = @vpn.login.type == Model::PassTypes.ask ? 0 : 1
    @vpn_user.text = @vpn.login.user || ""
    activate_pass_entry if @vpn.login.type == Model::PassTypes.save
    deactivate_pass_entry if @vpn.login.type != Model::PassTypes.save
    @vpn_routes.text = @vpn.routes * ","
    @vpn_apps_sw.active = @vpn.target
    @vpn_apps.buffer.text = @vpn.apps * "\n"
    @vpn_default.active = @vpn.default
    self.select_styling(Model::State.active)
  end

  # Configure styling for a given vpn and state
  # @param state [Model::State] state to set styling for
  # @param force [Bool] true then set state regardless
  def select_styling(state, force:false)
    set_disconnect = ->(){
      _ctx = @connect_btn.style_context
      _ctx.remove_class('button-action')
      _ctx.add_class('button-disconnect')
      @connect_btn.label = "Disconnect"
    }
    set_connect = ->(){
      _ctx = @connect_btn.style_context
      _ctx.remove_class('button-disconnect')
      _ctx.add_class('button-action')
      @connect_btn.label = "Connect"
    }

    @vpns.each{|vpn|
      ctx = vpn.btn.style_context
      if state == Model::State.active
        if vpn.name == @vpn.name
          if force || vpn.state != Model::State.connected
            vpn.state = state
            ctx.add_class('button-active')
            ctx.remove_class('button-action')
            set_connect.call
          else
            set_disconnect.call
          end
        elsif vpn.state == Model::State.active
          vpn.state = nil
          ctx.remove_class('button-active')
        end
      elsif vpn.name == @vpn.name
        vpn.state = state
        ctx.add_class('button-action')
        set_disconnect.call
        ctx.remove_class('button-active')
      end
    }
  end

  # Add a new vpn button and select it
  def add_vpn
    # Ensure the vpn has a unique name
    name = "New VPN"
    i = (0..10).find{|i| !@vpns.any?{|x| x.name == "#{name} #{i}"}}
    name = "#{name} #{i}"

    # Create the vpn and select it
    vpn = Config.add_vpn(name)
    vpn.btn = Gtk::Button.new(label:name)
    @vpnlist_box.pack_start(vpn.btn)
    vpn.btn.signal_connect('clicked'){|x| self.select_vpn(x.label)}
    vpn.btn.show
    @vpns << vpn
    GtkAssist.applystyles(vpn.btn)
    self.select_vpn(vpn.name)
  end

  # Remove the currently selected vpn
  def del_vpn
    return unless @vpn
    @vps.delete(@vpn)
    @vpnlist_box.remove(@vpn.btn)
    Config.del_vpn(@vpn.name)
    @vpn = nil
    self.select_default_or_first_vpn
  end

  # Save the active vpn
  def save_vpn
    return unless @vpn
    @vpn.name = @vpn_name.text
    @vpn.login.type = @vpn_logintype.active == 0 ? Model::PassTypes.ask : Model::PassTypes.save
    @vpn.login.user = @vpn_user.text

    @vpn.login.pass = @vpn_pass.text
    @vpn.routes = @vpn_routes.text.split(',')
    @vpn.ovpn = File.join(Config.ovpn_path, @vpn_ovpn.active_text)
    @vpn.target = @vpn_apps_sw.active?
    @vpn.apps = @vpn_apps.buffer.text.split("\n")
    @vpn.default = @vpn_default.active?
    Config.update_vpn(@vpn)

    # Update the button label after as its used as itentifier first
    @vpn.btn.label = @vpn.name
    Config.save
  end

  # Connect/disconnect to the selected vpn
  def connect_or_disconnect
    self.save_vpn

    # Connect the current connected vpn
    if @vpn.state == Model::State.active
      pass = @vpn.login.pass if @vpn.login.type == Model::PassTypes.save
      if @vpn.login.type == Model::PassTypes.ask
        diag = GetPass.new(@main_win)
        #x, y = @main_win.position
        #@pass_diag.move(x, y)
        #pass = @pass_entry.text if @pass_diag.run == Gtk::ResponseType::OK
        #@pass_entry.text = ""
        #@pass_diag.hide
      end
      puts(pass)
      self.select_styling(Model::State.connected)

    # Disconnect the current connected vpn
    else
      puts("VPN: #{@vpn.name} - disconnecting")
      self.select_styling(Model::State.active, force:true)
    end
  end

  # Configure signals
  def connect_signals

    # Exit on Alt-F4 or Escape
    @main_win.signal_connect('destroy'){ Gtk.main_quit }
    @main_win.signal_connect('key_press_event'){|w,e|
      Gtk.main_quit if e.keyval == Gdk::Keyval::KEY_Escape
    }

    # Connect button
    @connect_btn.signal_connect('clicked'){|x| self.connect_or_disconnect}
    @save_btn.signal_connect('clicked'){|x| self.save_vpn}

    # Add/del vpn button
    @builder.get_object("add-button").signal_connect('clicked'){|btn| self.add_vpn}
    @builder.get_object("delete-button").signal_connect('clicked'){|btn| self.del_vpn}

    # Show password
    @vpn_pass.signal_connect('icon-press'){|entry| entry.visibility = !entry.visibility?}
    @vpn_logintype.signal_connect('changed'){|combo|
      activate_pass_entry if @vpn_logintype.active != 0
      deactivate_pass_entry if @vpn_logintype.active == 0
    }

    # Configure signals/actions for vpnlist
    @vpns.each{|x| x.btn.signal_connect('clicked'){|btn| self.select_vpn(btn.label)}}
  end

  # Setup window to be able to be repositioned
  # by clicking on non-child widget area to move with dragging
  # @param win [GtkWindow] window to enable repositioning for
  def enable_repositioning(win)
    @reposition ||= {}
    id = win.object_id

    win.signal_connect('button_press_event'){|w,e|
      if e.button == 1                          # Start on repositioning on left mouse click
        @reposition[id] = [e.x, e.y]            # Add window to repositioning hash for tracking
        win.window.set_cursor(@cursor_grabbing) # Set cursor to grabbing for movement indication
        win.grab_add                            # Ignore all other widget input during movement
      end
    }
    win.signal_connect('button_release_event'){
      @reposition.delete(id)                    # Remove from currently repositioning tracking
      win.window.set_cursor(nil)                # Reset cursor back to 'default'
      win.grab_remove                           # Remove block on other widget inputs
    }
    win.signal_connect('motion_notify_event'){|w,e|
      if @reposition.key?(id)
        # Motion event coordinants are in reference to the widget and go negative when leaving
        # window borders. Thus movement of window position can be calculated by the postion of the
        # window + the difference of x1 and x2. Since 0,0 is top left we do it backwards  e.g.
        # x + (x2 - x1) = new position
        _win, motion_x, motion_y, state = w.window.get_device_position(e.device)
        old_x, old_y = w.position
        new_x = old_x + (motion_x - @reposition[id].first)
        new_y = old_y + (motion_y - @reposition[id].last)
        win.move(new_x, new_y)
      end
    }
  end

#  # Create the system tray icon
#  # returns [Gtk::StatusIcon] system tray icon
#  def create_system_tray_icon
#    tray = Gtk::StatusIcon.new
#    tray.pixbuf = GdkPixbuf::Pixbuf.new(file:@icon)
#
#    # Left click menu?
#    tray.signal_connect('activate'){|widget|
#      widget.pixbuf = GdkPixbuf::Pixbuf.new(file:@targeted_icon)
#    }
#
#    return tray
#  end
#
#  # Create the popup menu for the system tray icon
#  # returns [Gtk::Menu] popup menu
#  def create_popup_menu
#    menu = Gtk::Menu.new
#
#    # Add enable entry
#    enable = Gtk::ImageMenuItem.new(label: "Enable")
#    enable.image = Gtk::Image.new(pixbuf: GdkPixbuf::Pixbuf.new(file:@enabled_icon, width:16, height:16))
#    enable.signal_connect('activate'){ start_and_manage_vpn(false) }
#    menu.append(enable)
#
#    # Add target entry
#    target = Gtk::ImageMenuItem.new(label: "Target")
#    target.image = Gtk::Image.new(pixbuf: GdkPixbuf::Pixbuf.new(file:@targeted_icon, width:16, height:16))
#    target.signal_connect('activate'){ start_and_manage_vpn(true) }
#    menu.append(target)
#
#    # Add disable entry
#    disable = Gtk::ImageMenuItem.new(label: "Disable")
#    disable.image = Gtk::Image.new(pixbuf: GdkPixbuf::Pixbuf.new(file:@disabled_icon, width:16, height:16))
#    disable.signal_connect('activate'){ @vpn_comm_in << CommMsg.new(CommCmd.halt, nil) }
#    menu.append(disable)
#    menu.append(Gtk::SeparatorMenuItem.new)
#
#    # Add settings entry
#    settings = Gtk::ImageMenuItem.new(stock: Gtk::Stock::PREFERENCES)
#    settings.label = "Settings"
#    settings.signal_connect('activate'){ @settings.show_all }
#    menu.append(settings)
#
#    # Add log entry
#    log = Gtk::ImageMenuItem.new(stock: Gtk::Stock::PREFERENCES)
#    log.label = "Logs"
#    log.signal_connect('activate'){ @logwin.show_all }
#    menu.append(log)
#    menu.append(Gtk::SeparatorMenuItem.new)
#
#    # Add quit entry
#    quit = Gtk::ImageMenuItem.new(stock: Gtk::Stock::QUIT)
#    quit.signal_connect('activate'){
#      @halt = true
#      if @vpn_comm_in
#        @vpn_comm_in << CommMsg.new(CommCmd.halt, nil)
#      else
#        Gtk.main_quit
#      end
#    }
#    menu.append(quit)
#
#    # Handle popup menu signal
#    @tray.signal_connect('popup-menu'){|widget, button, time|
#      menu.popup(nil, nil, button, time)
#    }
#
#    menu.show_all
#    return menu
#  end
#
#  # Create the log window
#  # https://github.com/ruby-gnome2/ruby-gnome2/blob/master/gtk3/sample/gtk-demo/textview.rb
#  # @returns [Gtk::Window] the log window to work with
#  def create_log_window
#    logwin = Gtk::Window.new
#    logwin.title = "OpenVPN PIA - Logs"
#    logwin.set_default_size(1000,700)
#    logwin.icon = GdkPixbuf::Pixbuf.new(file:@icon)
#    logwin.override_background_color(:normal, Gdk::RGBA.new(0, 0, 0, 0))
#
#    # Create a scrollable text view
#    @logview = Gtk::TextView.new
#    @logview.editable = false
#    @logview.override_background_color(:normal, Gdk::RGBA.new(0, 0, 0, 0))
#    scroll = Gtk::ScrolledWindow.new
#    scroll.set_policy(:automatic, :automatic)
#    scroll.add(@logview)
#    logwin.add(scroll)
#
#    # Automatically scroll window
#    @logview.signal_connect("size-allocate"){
#      scroll.vadjustment.value = scroll.vadjustment.upper - scroll.vadjustment.page_size
#    }
#
#    # Configure text view
#    @logview.buffer.create_tag("font", "font" => "Mono 11")
#    ColorMap.each{|code, color| @logview.buffer.create_tag(color, "foreground" => color) }
#    @logiter = @logview.buffer.get_iter_at(offset: 0)
#    log("OpenVPN PIA Logs\n".colorize(:cyan))
#
#    # Hide log window on escape
#    logwin.signal_connect('delete-event'){|widget, event|
#      widget.hide_on_delete
#    }
#    logwin.signal_connect('key_press_event'){|widget, event|
#      logwin.visible = false if event.keyval == Gdk::Keyval::KEY_Escape
#    }
#
#    return logwin, @logview, @logiter
#  end
#
#  # Create the settings window
#  # @returns [Gtk::Window] the settings window to work with
#  def create_settings_window
#    settings = @builder.get_object("settings")
#    settings.title = "OpenVPN PIA - Settings"
#    settings.icon = GdkPixbuf::Pixbuf.new(file:@icon)
#
#    # Add all vpn gateways to the menu
##    @openvpn_configs.each{|x|
##      gateway = File.basename(x, '.ovpn')
##      item = Gtk::ImageMenuItem.new(gateway)
##
##      # Determine correct flag to use for the given gateway
##      flag = @flags.find{|x| x if gateway.start_with?(File.basename(x, '.png')[/flag-(.*)/, 1])}
##      item.image = Gtk::Image.new(GdkPixbuf::Pixbuf.new(file:flag, width:16, height:16)) if flag
##      menu.append(item)
##    }
#
#    # Populate the combo box
#    region_combo = @builder.get_object("region_combo")
#    @openvpn_configs.each{|x|
#      gateway = File.basename(x, '.ovpn')
#      region_combo.append_text(gateway)
#    }
#    region_combo.set_active(0)
#
#    # Read in and set settings
#    username_entry = @builder.get_object("username_entry")
#    password_entry = @builder.get_object("password_entry")
#    target_entry = @builder.get_object("target_entry")
#    if File.exist?(@config)
#      File.open(@config, 'r'){|f|
#        lines = f.readlines
#        username_entry.text = lines[0].strip if lines.any?
#        password_entry.text = lines[1].strip if lines.size > 1
#        if lines.size > 2
#          index = @openvpn_configs.index{|x| x == lines[2].strip}
#          region_combo.set_active(index)
#        end
#        target_entry.text = lines[3].strip if lines.size > 3
#      }
#    end
#
#    # Hide settings window
#    cancel_btn = @builder.get_object("cancel_btn")
#    settings.signal_connect('delete-event'){|widget, event|
#      widget.hide_on_delete
#    }
#    cancel_btn.signal_connect('clicked'){
#      settings.visible = false
#    }
#    settings.signal_connect('key_press_event'){|widget, event|
#      settings.visible = false if event.keyval == Gdk::Keyval::KEY_Escape
#    }
#
#    # Save out settings
#    save_btn = @builder.get_object("save_btn")
#    save_btn.signal_connect('clicked'){
#      File.open(@config, 'w'){|f|
#        f.puts(username_entry.text)
#        f.puts(password_entry.text)
#        if region_combo.active > -1
#          f.puts(@openvpn_configs[region_combo.active])
#        else
#          f.puts("")
#        end
#        f.puts(target_entry.text)
#      }
#      File.chmod(0600, @config)
#      settings.visible = false
#    }
#
#    return settings
#  end
#
#  # Start and manage the vpn
#  # @param target_mode [Boolean] true then run in target mode
#  def start_and_manage_vpn(target_mode)
#    return if !@vpn_comm_in.nil?
#    @vpn_comm_in = Queue.new
#
#    region_combo = @builder.get_object("region_combo")
#    openvpn_config = @openvpn_configs[region_combo.active]
#    app = target_mode ? @builder.get_object("target_entry").text : nil
#
#    Thread.new{
#      begin
#        vpn = VPN.new(@log, "pia", @config, openvpn_config, nameservers: ["209.222.18.222", "209.222.18.218"])
#        thread, vpn_comm_out = vpn.run(@vpn_comm_in, app: app)
#
#        msg = false
#        while true do
#          sleep(0.25) if !msg
#          msg = false
#
#          # Incoming notification
#          if !vpn_comm_out.empty?
#            msg = vpn_comm_out.pop
#            log(@log.format("CMD: #{msg.cmd}, Value: #{msg.value}\n").colorize(:magenta))
#
#            # Set icon for tunnel up status
#            if msg.cmd == CommCmd.tun_up
#              icon = target_mode ? @targeted_icon : @enabled_icon
#              @tray.pixbuf = GdkPixbuf::Pixbuf.new(file:icon)
#
#            # Set icon disabled status
#            elsif msg.cmd == CommCmd.tun_down
#              @tray.pixbuf = GdkPixbuf::Pixbuf.new(file:@disabled_icon)
#
#            # Handle halt ack
#            elsif msg.cmd == CommCmd.halt
#              Gtk.main_quit if @halt
#              break
#            end
#          end
#
#          # Print log messages
#          if !@log.empty?
#            msg = true
#            log(@log.pop)
#          end
#        end
#      rescue Exception => e
#        log(e)
#      ensure
#        @vpn_comm_in = nil
#        @tray.pixbuf = GdkPixbuf::Pixbuf.new(file:@disabled_icon)
#      end
#    }
#  end
#
#  # Add the colorized string to the given text buffer
#  # @param str [String] string with ansi color codes
#  def log(str)
#    @log.tokenize_colorize(str).each{|token|
#      @logview.buffer.insert(@logiter, token.str, tags: [ColorMap[token.color], "font"])
#    }
#  end
end

#-------------------------------------------------------------------------------
# Main entry point
#-------------------------------------------------------------------------------
if __FILE__ == $0
  VpnCtl.new
  Gtk.main
end

# vim: ft=ruby:ts=2:sw=2:sts=2
