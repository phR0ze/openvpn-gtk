#!/usr/bin/env ruby
#MIT License
#Copyright (c) 2018 phR0ze
#
#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.

require 'ostruct'               # OpenStruct
require 'open3'                 # Better system commands
require 'socket'                # Networking support

require 'colorize'              # Color output
require 'nub'                   # Commands

CommCmd = OpenStruct.new({
  halt: 'halt',
  vpn_up: 'vpn_up',
  vpn_down: 'vpn_down',
})

class VPN
  # Initialize this VPN instance
  # @param vpn [String] name of the vpn to use
  # @param pass [String] password to use with the VPN
  def initialize(vpn, pass)
    Log.puts("Error: must be executed as root".colorize(:red)) and exit unless User.root?
    Log.puts("Error: IPForward=kernel must be set!") and exit unless Net.ip_forward?

    @vpn = vpn
    @pass = pass

    # Get configs
    vpns = Config['vpns']
    raise("couldn't find 'vpns' in config") if vpns.nil?
    _vpn = vpns.find{|x| x['name'] == @vpn }
    raise("couldn't find '#{@vpn}' in config") if _vpn.nil?
    @user = _vpn['user']
    raise("couldn't find 'user' in config") if @user.nil?
    @route = _vpn['route']
    raise("couldn't find 'route' in config") if @route.nil?
    @openvpn_conf = _vpn['conf']
    raise("couldn't find 'conf' in config") if @openvpn_conf.nil?
    @auth_path = File.join(File.dirname(@openvpn_conf), "#{@vpn}.auth")
  end

  # Start and manage the vpn connection in a separate thread
  def start
    return ThreadComm.new{|comm_in, comm_out|
      count = 0
      halt = false

      while !halt do
        begin
          # Write out the auth file for OpenVPN to read
          File.open(@auth_path, "w", 0600){|f| f.puts(@user); f.puts(@pass)}

          retry_str = " - retry #{count}" if count > 0
          Log.puts("Starting the VPN connection#{retry_str}".colorize(:yellow))
          Log.puts("Using OpenVPN config #{@openvpn_conf.colorize(:cyan)}")

          # (2) OpenVPN thread: manages the openvpn process
          resolved_script = "/etc/openvpn/scripts/update-systemd-resolved"
          env_path = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
          cmd = "openvpn --config #{@openvpn_conf} --setenv '#{env_path}' --script-security 2 "
          cmd += "--up #{resolved_script} --down #{resolved_script} --down-pre "
          cmd += "--auth-user-pass #{@auth_path}"
          stdin, stdout, openvpn_thread = Open3.popen2e("bash -c '#{Net.proxy_export}#{cmd}'")

          # (3) Log thread: Start a separate log thread drain stdout to logs
          log_thread = Thread.new{
            while line=stdout.gets do
              if line.include?("Initialization Sequence Completed")
                comm_in << ThreadMsg.new(CommCmd.vpn_up)
              end
              Log.puts("#{'OVPN:'.colorize(:yellow)} #{line.strip}")
            end
          }

          # Manage thread communication and actions
          vpn_started = false
          while true do
            Log.puts("Waiting for vpn #{@vpn.colorize(:cyan)} to be started...") if !vpn_started
            if !comm_in.empty?
              msg = comm_in.pop
              
              # Wait for tunnel to be created
              if msg.cmd == CommCmd.vpn_up && !vpn_started
                vpn_started = true
                Log.puts("VPN #{@vpn.colorize(:cyan)} is up and running")
                comm_out << ThreadMsg.new(CommCmd.vpn_up)

                # Add any routes from the configuration
                tun_ip = Socket.getifaddrs.find{|x| x.addr and x.name == 'tun0' and x.addr.ipv4?}.addr.ip_address
                Log.print("Adding route #{@route.colorize(:cyan)} for #{tun_ip.colorize(:cyan)} on tun0")
                exec_with_status("ip route add #{@route} via #{tun_ip} dev tun0")
              end

              # Terminate
              if msg.cmd == CommCmd.halt
                Log.puts("Halting the management thread")
                raise SystemExit
              end
            else
              sleep(0.25)
            end

            # Monitor vpn
            raise(Exception, "OpenVPN connection failed") if !openvpn_thread.alive?
          end

        # Allow for aborting
        rescue SystemExit, Interrupt
          halt = true

        # Log exceptions
        rescue Exception => e
          Log.puts("#{e.to_s}".colorize(:red))
          comm_out << ThreadMsg.new(CommCmd.tun_down)

        # Clean up on errors and try again
        ensure
          File.delete(@auth_path) if File.exist?(@auth_path)
          stdin.close if !stdin.nil?
          stdout.close if !stdout.nil?
          if openvpn_thread and openvpn_thread.alive?
            Process.kill("KILL", openvpn_thread.pid)
            openvpn_thread.kill
          end

          # Wait for log to drain then send out halt notification
          sleep(0.25)
          while !Log.empty? do
            sleep(0.25)
          end
          comm_out << ThreadMsg.new(CommCmd.halt) if halt
        end

        # Retry sleep logic
        if halt
          Log.puts("System exit or user terminated!".colorize(:yellow))
        else
          count += 1
          Log.puts("OpenVPN terminated/disconnected waiting 10".colorize(:red))
          sleep(10)
        end
      end
    }
  end

  # Execute the shell command and print status
  # @param cmd [String] command to execute
  # @param die [bool] exit on true
  # @result status [bool] true on success else false
  def exec_with_status(cmd, die:true, check:nil)
    out = `#{cmd}`
    status = true
    status = check == out if !check.nil?
    status = $?.exitstatus == 0 if check.nil?

    #if status
    if $?.exitstatus == 0
      Log.puts("...success!".colorize(:green), stamp:false)
    else
      Log.puts("...failed!".colorize(:red), stamp:false)
      Log.puts(out.colorize(:red)) and exit if die
    end

    return status
  end
end

#-------------------------------------------------------------------------------
# Main entry point
#-------------------------------------------------------------------------------
if __FILE__ == $0
  app = 'openvpn-cli'
  version = '0.0.1'
  examples = "Examples:\n".colorize(:green)
  examples += "Start VPN: sudo ./#{app} start --vpn=ospra\n".colorize(:green)

  opts = Cmds.new(app, version, examples)
  opts.add('start', 'Start VPN service', [
    CmdOpt.new('--vpn=VPN_NAME', 'VPN name to lookup in config', type:String, required: true),
  ])
  opts.parse!

  # Execute
  puts(opts.banner)

  # Create the vpn instance to work with
  require 'io/console'
  print("Enter Password: ")
  pass = STDIN.noecho(&:gets).chomp

  # Init utils
  Config.init('openvpn.yml')

  # Start the VPN
  if opts[:start]
    begin
      vpn = VPN.new(opts[:vpn], pass).start
      Log.puts("MGMT: Waiting for VPN to halt".colorize(:magenta))
      vpn.join
    rescue Interrupt
      Log.puts(stamp:false)
      Log.puts("MGMT: Halting VPN".colorize(:magenta))
      vpn.push(CommCmd.halt)
      vpn.pop
      Log.puts("MGMT: VPN Halted".colorize(:magenta))
    end
  end
end

# vim: ft=ruby:ts=2:sw=2:sts=2
